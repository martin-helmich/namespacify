#!/usr/bin/env php
<?php

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Martin Helmich <kontakt@martin-helmich.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


$shortopts = "h";
$longopts  = [
	"help",
	"backup",
	"source-namespace:",
	"target-namespace:",
	"directory:"
];

$options   = getopt($shortopts, $longopts);

if (array_key_exists('help', $options) || array_key_exists('h', $options)) {
	usage();
	exit(0);
}

if (!array_key_exists('source-namespace', $options)) {
	usage();
	echo PHP_EOL;
	fwrite(STDERR, 'Missing argument: source-namespace' . PHP_EOL);
	exit(1);
} else {
	$sourcePseudoNamespace = $options['source-namespace'];
}

if (!array_key_exists('target-namespace', $options)) {
	usage();
	echo PHP_EOL;
	fwrite(STDERR, 'Missing argument: target-namespace' . PHP_EOL);
	exit(1);
} else {
	$targetNamespace = $options['target-namespace'];
}

if (!array_key_exists('target-namespace', $options)) {
	usage();
	echo PHP_EOL;
	fwrite(STDERR, 'Missing argument: target-namespace' . PHP_EOL);
	exit(1);
} else {
	$targetNamespace = $options['target-namespace'];
}

if (!array_key_exists('directory', $options)) {
	$targetDirectory = '.';
} else {
	$targetDirectory = $options['directory'];
}

if (!array_key_exists('backup', $options)) {
	$backup = FALSE;
} else {
	$backup = TRUE;
}

function usage() {
	global $argv;

	echo 'USAGE:' . PHP_EOL;
	echo '    ' . $argv[0] . ' --source-namespace Foo_Bar --target-namespace \'Foo\\Bar\' [--directory=.]' . PHP_EOL . PHP_EOL;
	echo 'ARGUMENTS:' . PHP_EOL;
	echo '    --help             This help.' . PHP_EOL;
	echo '    --source-namespace Source (pseudo) namespace (e.g. \'Foo_Bar\').' . PHP_EOL;
	echo '    --target-namespace The target namespace to convert into (e.g. \'Foo\\Bar\').' . PHP_EOL;
	echo '    --directory        The directory to parse.' . PHP_EOL;
}

function convertClassName($oldClassName) {
	global
		$sourcePseudoNamespace,
		$targetNamespace;

	$class = str_replace($sourcePseudoNamespace, $targetNamespace, $oldClassName);
	$class = str_replace('_', '\\', $class);

	return $class;
}

function getNamespace($namespacedClassName) {
	$components = explode('\\', $namespacedClassName);
	array_pop($components);
	return implode('\\', $components);
}

function handleFile($filename) {
	global
		$sourcePseudoNamespace,
		$targetNamespace,
		$backup;

	echo "Tokenizing $filename..." . PHP_EOL;

	$fileContent = file_get_contents($filename);
	$tokens      = token_get_all($fileContent);
	$namespace   = NULL;

	$count = count($tokens);
	for ($i = 0; $i < $count; ++ $i) {
		$token = $tokens[$i];
		if (!is_array($token)) {
			continue;
		}

		if ($token[0] === T_NAMESPACE) {
			echo "File is already namespaced." . PHP_EOL;
			echo "Done." . PHP_EOL;
			return;
		}

		if ($token[0] === T_CLASS || $token[0] === T_INTERFACE) {
			for (++ $i; $tokens[$i][0] === T_WHITESPACE; ++ $i);

			$class = $oldClass = $tokens[$i][1];
			$class = str_replace($sourcePseudoNamespace, $targetNamespace, $class);
			$class = str_replace('_', '\\', $class);

			echo $oldClass . " -> " . $class . PHP_EOL;

			$components = explode('\\', $class);
			$realClass = array_pop($components);
			$namespace = implode('\\', $components);

			$tokens[$i] = $realClass;
		}

		if ($token[0] === T_CONSTANT_ENCAPSED_STRING) {
			if (strpos($token[1], $sourcePseudoNamespace) !== FALSE) {
				$class = trim($token[1], '\'"');
				$class = convertClassName($class);

				$tokens[$i][1] = '\'\\\\' . addslashes($class) . '\'';
			}
		}

		if ($token[0] === T_STRING && strpos($token[1], $sourcePseudoNamespace) === 0) {
			$class = convertClassName($token[1]);

			if ($namespace !== NULL && $namespace === getNamespace($class)) {
				$tokens[$i][1] = str_replace($namespace . '\\', '', $class);
			} else {
				$tokens[$i][1] = '\\' . $class;
			}
		}

		if ($token[0] === T_DOC_COMMENT) {
			$tokens[$i][1] = preg_replace_callback(
				',(' . $sourcePseudoNamespace . '[a-zA-Z_]+),',
				function ($matches) {
					return '\\' . convertClassName($matches[1]);
				},
				$tokens[$i][1]
			);
		}
	}

	if ($namespace !== NULL) {
		$namespaceTokens = [
			[T_NAMESPACE, 'namespace'],
			[T_WHITESPACE, ' '],
			[T_STRING, $namespace],
			';',
			[T_WHITESPACE, "\n\n"]
		];

		for ($i = 0; $i < $count && (is_string($tokens[$i]) || $tokens[$i][0] !== T_OPEN_TAG); ++ $i);

		$firstPart = array_slice($tokens, 0, $i + 1);
		$secondPart = array_slice($tokens, $i + 1);

		$tokens = array_merge($firstPart, $namespaceTokens, $secondPart);
	}

	$content = printFile($tokens);

	if ($backup) {
		copy($filename, $filename . '.bak');
	}

	file_put_contents($filename, $content);

	echo "Done." . PHP_EOL;
}

function printFile(array $tokens) {
	$content = '';
	foreach ($tokens as $token) {
		if (is_array($token)) {
			$content .= $token[1];
		} else {
			$content .= $token;
		}
	}
	return $content;
}

$directoryIterator = new \RecursiveDirectoryIterator($targetDirectory);
$iterator          = new \RecursiveIteratorIterator($directoryIterator);
$regexIterator     = new \RegexIterator($iterator, '/^.+\.php$/', \RecursiveRegexIterator::GET_MATCH);

foreach ($regexIterator as $key => $value) {
	handleFile($value[0]);
}
